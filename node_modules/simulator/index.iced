plot = require('plotter').plot

clamp = (val, low, high) ->
	Math.max low, Math.min high, val

R = (node, project, t) -> 
	calculationCorrectnessScaled(node, project)

randR = (node, project, t) ->
	clamp(R(node, project, t) + (Math.random() * 0.2 - 0.1), 0, 1)

historicalExperienceScale = (node, t) -> 0

calculationCorrectnessScaled = (node, project) ->
	max = project.best_r
	if max == 0
		return 0
	else
		ccor = calculationCorrectness(node, project)
		return ccor / max

calculationCorrectness = (node, project) ->
	project.find_confirmed_r node
		
class Project
	constructor: ->
		@workunits = []
		@participants = []
		@best_r = 0

	add_node: (node) ->
		@participants.push node

	find_work: (node) ->
		score = R node, this

		feasible = []
		optimal = null
		for work in @workunits
			work_score = work.get_best_total_score()
			if work_score >= 1
				continue
				
			if work.has_result_from(node) != null
				continue

			if optimal == null
				optimal = work
				continue

			if optimal.get_best_total_score() > work_score
				optimal = work

			if work_score + score < 1
				feasible.push work

		if feasible.length > 0
			return feasible[Math.floor(Math.random() * feasible.length)]

		#if optimal
		#	console.log "returning #{optimal.id} score: #{optimal.get_best_total_score()}"
		return optimal
		
	find_confirmed_r: (node) ->
		total_score = 0

		for work in @workunits
			for result in work.results
				if result.node == node
					total_score += result.total_score - result.score
		return total_score

	find_best_confirmed_r: ->
		scores = {}

		for work in @workunits
			for result in work.results
				nid = result.node.id
				unless scores[nid]?
					scores[nid] = 0

				scores[nid] += result.total_score - result.score

		score_max = 0
		for node,score of scores
			score_max = Math.max score_max, score

		@best_r = score_max

class Work
	constructor: (@id, @project) ->
		@results = []

		@done = false

	get_best_total_score: ->
		max = 0
		for result in @results
			max = Math.max max, result.total_score
		return max

	has_result_from: (node) ->
		for result in @results
			if result.node == node
				return result
		return null

	finish: (node) ->
		node_score = randR node, @project

		total_score = node_score
		if @results.length > 0
			total_score += @results[0].total_score

		for result in @results
			result.total_score = total_score

		@results.push {
			node: node
			score: node_score
			total_score
		}

		if(!@done and total_score >= 1)
			console.log "F: work_id: #{@id} node_id: #{node.id} node_score: #{node_score} results: #{@results.length} total_score: #{total_score}"
			@done = true
			return true
		else
			return false

class Node
	constructor: (@id) ->
		@busy = 0
		@assigned_work = null

		# Number of tick for node to do work unit
		# "speed of node"
		@work_time = 1 + Math.random() * 5 + 5

	sleep_time: (tick) ->
		# default sleep time
		return 0

proj = new Project()

work_done = 0

for i in [0..500]
	proj.workunits.push new Work i, proj

nodes = []

for i in [0..50]
	node = new Node i
	nodes.push node
	proj.add_node node

tick = 0


while work_done < proj.workunits.length
	for node in nodes
		if node.busy > 0
			if(--node.busy <= 0)
				if node.assigned_work and node.assigned_work.finish(node)
					work_done++
					node.assigned_work = null
					
					sleeptime = node.sleep_time(tick)
					if sleeptime >= 1
						# node randomly goes to sleep for 9 - 11 ticks
						node.busy = sleeptime
		else
			work = proj.find_work node
			if work == null
				#no work for node?
			else
				node.assigned_work = work
				# node goes to work for 4 - 6 ticks
				node.busy = node.work_time

		proj.find_best_confirmed_r()

	tick++
	#console.log "#{tick}"

