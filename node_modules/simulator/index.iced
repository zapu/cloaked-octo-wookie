fs = require 'fs'

clamp = (val, low, high) ->
	Math.max low, Math.min high, val

alpha = 0.5

R = (node, project, t) -> 
	R_ex node.historical_exp, calculationCorrectnessScaled(node, project)

R_ex = (historical_exp, calc_corr) ->
	alpha * historical_exp +
	(1 - alpha) * calc_corr

randR = (node, project, t) ->
	clamp(R(node, project, t) + (Math.random() * 0.2 - 0.1), 0, 1)

historicalExperienceScale = (node, t) -> 0

calculationCorrectnessScaled = (node, project) ->
	max = project.best_r
	if max == 0
		return 0
	else
		ccor = calculationCorrectness(node, project)
		return ccor / max

calculationCorrectness = (node, project) ->
	project.find_confirmed_r node
		

selectMax = (coll, fn_comp, fn_allow = null) ->
	max = null
	for item in coll
		if fn_allow and fn_allow(item) == false
			continue

		if max == null
			max = item
			continue

		if fn_comp max, item
			max = item

	return max

class Project
	constructor: ->
		@workunits = []
		@participants = []
		@best_r = 0

	add_node: (node) ->
		@participants.push node

	find_work: (node) ->
		calc_corr = calculationCorrectnessScaled(node, @)

		score = R_ex node.historical_exp, calc_corr

		node.last_score = score
		node.last_calc_corr = calc_corr

		feasible = []
		optimal = null
		for work in @workunits
			if work.done
				continue

			if work.has_result_from(node) != null
				continue

			if optimal == null
				optimal = work
				continue

			work_score = work.get_best_total_score()
			opt_score = optimal.get_best_total_score()

			if opt_score > work_score
				optimal = work
				
			if (work_score + score) > 1 and (opt_score + score) > 1
				if (1 - opt_score) < (1 - work_score)
					optimal = work

		#if optimal
		#	console.log "returning #{optimal.id} score: #{optimal.get_best_total_score()}"
		return optimal
		
	find_confirmed_r: (node) ->
		total_score = 0

		for work in @workunits
			for result in work.results
				if result.node == node
					total_score += result.total_score - result.score
		return total_score

	find_best_confirmed_r: ->
		scores = {}

		for work in @workunits
			for result in work.results
				nid = result.node.id
				unless scores[nid]?
					scores[nid] = 0

				scores[nid] += result.total_score - result.score

		score_max = 0
		for node,score of scores
			score_max = Math.max score_max, score

		@best_r = score_max

class Work
	constructor: (@id, @project) ->
		@results = []

		@done = false

	get_best_total_score: ->
		max = 0
		for result in @results
			max = Math.max max, result.total_score
		return max

	has_result_from: (node) ->
		for result in @results
			if result.node == node
				return result
		return null

	finish: (node) ->
		node_score = randR node, @project

		total_score = node_score
		if @results.length > 0
			total_score += @results[0].total_score

		for result in @results
			result.total_score = total_score

		@results.push {
			node: node
			score: node_score
			total_score
		}

		if(!@done and total_score >= 1)
			console.log "F: work_id: #{@id} node_id: #{node.id} node_score: #{node_score} results: #{@results.length} total_score: #{total_score}"
			@done = true
			return true
		else
			return false

class Node
	constructor: (@id) ->
		@busy = 0
		@assigned_work = null

		@last_score = 0

		# Number of tick for node to do work unit
		# "speed of node"
		@work_time = 1 + Math.random() * 5 + 5

		@historical_exp = 0

		@accept_work = true

	sleep_time: (tick) ->
		# default sleep time
		return Math.random() * 4

proj = new Project()

work_done = 0

for i in [0..1000]
	proj.workunits.push new Work i, proj

nodes = []

for i in [0..50]
	node = new Node i
	nodes.push node
	proj.add_node node

	if i > 40
		# very old nodes with high historical experience
		node.historical_exp = 0.7 + Math.random() * 0.3
	else if i > 10
		# moderately old nodes
		node.historical_exp = 0.7 * Math.random()
	else
		# new nodes
		node.historical_exp = 0


# For easier charting, set specific nodes at the beginning of the list
nodes[0].historical_exp = 0
nodes[1].historical_exp = 0.7 * Math.random()
nodes[2].historical_exp = 0.7 + Math.random() * 0.3
for i in [0..2]
	nodes[i].work_time = 8
	nodes[i].sleep_time = (tick) -> 2

# Turn node 3 off
# node 3 is a new node (historical_exp = 0)
nodes[3].accept_work = false

# Turn node 50 off
# Node 50 is very old, historical_exp is high
nodes[50].accept_work = false
nodes[50].work_time = 3
nodes[50].sleep_time = -> 0


tick = 0

resultRows = []

makeResultsRow = (nodes) ->
	mapFn = (node) ->
		node.last_score

	nodes.map(mapFn)

result_count_sum = 0

while work_done < proj.workunits.length
	for node in nodes
		unless node.accept_work
			continue

		if node.busy > 0
			if(--node.busy <= 0)
				if node.assigned_work
					if node.assigned_work.finish(node)
						work_done++
						console.log "Total done: #{work_done}"
						
					node.assigned_work = null

					sleeptime = node.sleep_time(tick)
					if sleeptime >= 1
						# node randomly goes to sleep for 9 - 11 ticks
						node.busy = sleeptime
		else
			work = proj.find_work node
			if work == null
				console.log "no work!"
				#no work for node?
			else
				node.assigned_work = work
				# node goes to work for 4 - 6 ticks
				node.busy = node.work_time

		proj.find_best_confirmed_r()

	resultRows.push makeResultsRow(nodes).join(',')
	tick++
	#console.log "#{tick}"

	if tick == 2000
		# Turn node 3 and node 50 on
		nodes[3].accept_work = true
		nodes[50].accept_work = true

fs.writeFileSync('results.csv', resultRows.join('\n'))
