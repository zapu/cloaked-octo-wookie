credits = require './credits'
rcalc = require './reliability'

handleDbError = (err) ->
	return dbError: err

module.exports.getProject = (db, seller_pub_key, cb) ->
	# Shouldn't we be working on something?
	await db.view 'market/projects_with_participants', 
		startkey: [seller_pub_key], endkey: [seller_pub_key, {}]
		defer err, dbres

	return cb handleDbError err if err

	# seller is already on a project, return it
	if(dbres.length > 0)
		return cb null, dbres[0].value

	await db.view 'market/projects_by_ids', defer err, dbres
	return cb handleDbError err if err

	# Very sophisticated algorithm to select project goes here:
	project_doc = dbres[0].value

	project_doc.participants.push seller_pub_key

	# Add seller_pub_key as participant, insert into db
	await db.merge project_doc, defer err, dbres
	return cb handleDbError err if err

	return cb null, project_doc

module.exports.getWork = (db, seller_pub_key, project_id, cb) ->
	# Are we even on the project?
	await db.view 'market/projects_with_participants', 
		key: [seller_pub_key, project_id], 
		defer err, dbres

	return cb handleDbError err if err

	# seller_pub_key is not a participant of the project
	if dbres.length == 0
		return cb logicError: "seller_pub_key #{seller_pub_key} not on project #{project_id}"

	await db.view 'market/work_by_project_ids_and_requests',
		key: [seller_pub_key, project_id], 
		defer err, dbres

	return cb handleDbError err if err

	# Seller is already doing work, return it
	if dbres.length != 0
		return cb null, dbres[0].value

	await db.view 'market/work_unconfirmed_by_project_ids', key: project_id, 
		defer err, dbres

	return cb handleDbError err if err

	# All work is confirmed in this project
	if dbres.length == 0
		return cb null, null

	await rcalc.R seller_pub_key, project_id, defer score

	work_candidates = []
	for doc in dbres
		work = doc.value

		work.best_score = 0
	
		sellerWorkedOn = false
		for result in work.results
			if result.node == seller_pub_key
				sellerWorkedOn = true
			work.best_score = Math.max work.best_score, result.total_score

		unless sellerWorkedOn
			work_candidates.push work

	# *Seller* has no more work in this project
	if work_candidates.length == 0
		return cb null, null

	work_candidates.sort (a, b) ->
		a_score = a.best_score
		b_score = b.best_score
		if (a_score + score) > 1.1
			a_score *= 0.01
		if (b_score + score) > 1.1
			b_score *= 0.01

		return b_score - a_score

	console.log "#{seller_pub_key} (real score #{score}) gets new work"

	return cb null, work_candidates[0]


module.exports.tryFinishProject = (db, project_id, cb) ->
	await db.view 'market/unconfirmed_result_count',
		{ 
			key: project_id
			group: true
			reduce: true
		},
		defer err, dbres

	if dbres.length == 0 or dbres[0].value > 0
		return cb()

	console.log "Project #{project_id} is finished - all work confirmed."

	await credits.getFinishedProjectCount defer count

	await db.view 'market/projects_by_ids', key: project_id, defer err, dbres
	throw err if err

	project_doc = dbres[0]?.value
	project_doc.finished_id = count

	await db.merge project_doc, defer err, dbres
	throw err if err

	cb()


