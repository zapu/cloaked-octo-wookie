http = require 'http'
formidable = require 'formidable'
util = require 'util'
fs = require 'fs'
deepequal = require 'deep-equal'
crypto = require 'crypto'

inspectAll = (a) -> util.inspect a, false, null

httpsign = require './httpsign'
Router = require './router'
scheduler = require './scheduler'
rcalc = require './reliability'

torrents = require './torrent_download'
torrents.initTracker()

db = require './couch'

router = new Router()

# Adds route with signed parameters.
# - Each request must have pub_key parameter
# - Each of the fields or files must have correspondent
# "*-signed" parameter with signature (field/file signed 
# with pub_key)

addSignedRoute = (route, cb) ->
	router.addRoute route, (req, res, params, fields, files) ->
		form = new formidable.IncomingForm()
		await form.parse req, defer err, fields, files
		unless httpsign.verifyRequest(req, fields, files)
			res.writeHead 405
			res.end 'Signature error'
			return

		cb(req, res, params, fields, files)

checkKeys = (obj, keys) ->
	for key in keys
		unless key of obj
			return false

	return true

# Error handlers for routes

handleDatabaseError = (res, err) ->
	console.log 'CouchDB error', err
	console.trace()
	res.writeHead 500
	res.end 'Database error'

handleMalformedRequest = (res) ->
	res.writeHead 400
	res.end 'Malformed request'

server = http.createServer (request, response) ->
	unless router.routeRequest request, response
		response.writeHead 404
		response.end "404"

saveAttachmentEx = (db, doc, attachmentName, stream, callback) ->
	writeStream = db.saveAttachment doc, attachmentName, callback
	stream.pipe writeStream


addSignedRoute '/addProject', (req, res, params, fields, files) ->
	return handleMalformedRequest res unless checkKeys(files, ['program']) 	

	programStream = fs.createReadStream files.program.path

	doc = 
		type: 'project'
		pub_key: fields.pub_key
		participants: []
	
	await db.save doc, defer err, dbres
	return handleDatabaseError res, err if err

	await saveAttachmentEx db, { id: dbres._id, rev: dbres._rev },
		{ name: 'program', 'Content-Type': 'application/octet-stream' },
		programStream,defer err, dbres

	return handleDatabaseError res, err if err	

	delete dbres.headers

	res.writeHead 200
	res.end JSON.stringify dbres

addSignedRoute '/addWork', (req, res, params, fields, files) ->
	return handleMalformedRequest res unless \
		checkKeys(fields, ['project_id']) and 
		checkKeys(files, ['data']) 

	await db.get fields.project_id, defer err, project_doc
	return handleDatabaseError res, err if err

	# TODO: check signature with project.owner (a public key)
	# if fields.pub_key == project_doc.pub_key

	console.log files.data.path

	dataStream = fs.createReadStream files.data.path

	work_doc =
		type: 'work'
		project_id: project_doc._id
		project_rev: project_doc._rev
		results: []
		requests: []

	await db.save work_doc, defer err, dbres
	return handleDatabaseError res, err if err

	await saveAttachmentEx db, { id: dbres._id, rev: dbres._rev },
		{ name: 'data', 'Content-Type': 'application/octet-stream' },
		dataStream,	defer err, dbres

	return handleDatabaseError res, err if err	

	delete dbres.headers

	res.writeHead 200
	res.end JSON.stringify dbres


addSignedRoute '/registerSeller', (req, res, params, fields, files) ->
	await db.view 'market/sellers_by_pub_keys', key: fields.pub_key, defer err, dbres
	if dbres.length > 0
		res.writeHead 400
		res.end 'Seller with this public key already exists'
		return

	seller_doc = 
		type: 'seller'
		pub_key: fields.pub_key

	await db.save seller_doc, defer err, dbres
	return handleDatabaseError res, err if err

	res.writeHead 200
	res.end JSON.stringify dbres

handleSchedulerError = (err, res) ->
	if err.dbError?
		handleDatabaseError res, err
	else if err.logicError?
		res.writeHead 500
		res.end JSON.stringify ok: false, error: err.logicError

addSignedRoute '/getProject', (req, res, params, fields, files) ->
	# find project, send
	# also send work
	await scheduler.getProject db, fields.pub_key, defer err, project
	return handleSchedulerError err, res if err

	res.writeHead 200
	res.end JSON.stringify ok: true, _id: project._id

addSignedRoute '/downloadProject', (req, res, params, fields, files) ->
	return handleMalformedRequest res unless \
		checkKeys(fields, ['project_id'])

	await db.view 'market/projects_with_participants', 
		{ key: [fields.pub_key, fields.project_id] },
		defer err, dbres

	return handleDatabaseError res, err if err

	torrents.makeTorrentFromProgram db, dbres[0].value._id, res

addSignedRoute '/getWork', (req, res, params, fields, files) ->
	return handleMalformedRequest res unless \
		checkKeys(fields, ['project_id'])

	await scheduler.getWork db, fields.pub_key, fields.project_id, defer err, work
	return handleSchedulerError err, res if err

	unless work?
		res.writeHead 404
		res.end "No more work"
		return

	res.writeHead 200
	res.end JSON.stringify { ok: true, _id: work._id }

getAttachmentEx = (db, doc, attachment, stream, callback) ->
	readStream = db.getAttachment doc, attachment, callback
	readStream.pipe stream

addSignedRoute '/downloadWork', (req, res, params, fields, files) ->
	return handleMalformedRequest res unless \
		checkKeys(fields, ['work_id'])

	res.writeHead 200, 'Content-Type': 'application/octet-stream'

	await getAttachmentEx db, fields.work_id, 'data', res, defer err
	if err
		console.log 'CouchDB getAttachmentEx error', err
		res.end()

addSignedRoute '/submitWork', (req, res, params, fields, files) ->
	return handleMalformedRequest res unless \
		checkKeys(fields, ['work_id']) and 
		checkKeys(files, ['data']) 

	await db.view 'market/work_by_ids', key: fields.work_id, defer err, dbres
	if dbres.length == 0
		res.writeHead 400
		res.end "Work with id #{fields.work_id} does not exist"
		return

	work_doc = dbres[0].value

	await fs.readFile files.data.path, defer err, data
	if err
		console.log 'readFile error', err
		res.writeHead 400
		res.end 'Unable to process attachment'
		return

	shahash = crypto.createHash 'sha1'
	shahash.update data

	hash = shahash.digest 'hex'

	await rcalc.randR fields.pub_key, work_doc.project_id, defer score
	total_score = score
	score_found = false
	for result in work_doc.results
		if result.hash == hash
			unless score_found
				total_score += result.total_score
				score_found = true

			result.total_score = total_score
			break

	work_doc.results.push {
		node: fields.pub_key
		score
		total_score
		hash
	}

	await db.merge work_doc, defer err, dbres
	return handleDatabaseError res, err if err

	unless score_found
		# There is no result matching ours now, add attachment
		await db.saveAttachment { id: dbres._id, rev: dbres._rev },
			{ name: hash, 'Content-Type': 'application/octet-stream', body: data },
			defer err, dbres2

	res.writeHead 200
	res.end JSON.stringify dbres

	console.log "#{fields.pub_key} submits work for project: #{work_doc.project_id}, work: #{work_doc._id}, result score: #{total_score}"

	await scheduler.tryFinishProject db, work_doc.project_id, defer()

server.listen 8080, ->
	console.log 'listening'